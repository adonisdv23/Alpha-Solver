"""Release automation for Alpha Solver pilot v0.1.0."""
from __future__ import annotations

import argparse
import re
import subprocess
import sys
from pathlib import Path
from typing import Iterable, List

DEFAULT_VERSION = "0.1.0"
SUMMARY_TEMPLATES = {
    "0.1.0": [
        "Pilot readiness automation for Alpha Solver.",
        "Smoke deck plus quickstart documentation for the initial pilot cohort.",
        "Release script tags v0.1.0 without pushing remote refs.",
    ]
}


def _repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def _run_git(args: list[str], cwd: Path, check: bool = True) -> subprocess.CompletedProcess[str]:
    return subprocess.run(["git", *args], cwd=cwd, check=check, text=True, capture_output=True)


def _git_output(args: list[str], cwd: Path) -> str:
    proc = _run_git(args, cwd=cwd)
    return proc.stdout.strip()


def _previous_tag(cwd: Path, target_tag: str) -> str | None:
    proc = _run_git(["tag", "--sort=-creatordate"], cwd=cwd, check=False)
    if proc.returncode != 0:
        return None
    tags = [line.strip() for line in proc.stdout.splitlines() if line.strip()]
    for tag in tags:
        if tag == target_tag:
            continue
        return tag or None
    return None


def _changes_since(cwd: Path, last_tag: str | None) -> list[str]:
    if last_tag:
        proc = _run_git(["log", "--pretty=format:%h %s", f"{last_tag}..HEAD"], cwd=cwd)
        lines = [line.strip() for line in proc.stdout.splitlines() if line.strip()]
        if lines:
            return lines
        return [f"No commits since {last_tag}."]
    # First release fallback.
    return ["Initial release of the Alpha Solver pilot toolkit."]


def _release_date(cwd: Path) -> str:
    return _git_output(["log", "-1", "--format=%cs"], cwd=cwd)


def _build_notes(version: str, date: str, summary: Iterable[str], changes: Iterable[str]) -> str:
    lines: List[str] = [
        f"# Release Notes v{version}",
        "",
        f"- Tag: v{version}",
        f"- Date: {date}",
        "",
        "## Summary",
    ]
    for item in summary:
        lines.append(f"- {item}")
    lines.append("")
    lines.append("## Changes")
    for change in changes:
        lines.append(f"- {change}")
    lines.append("")
    return "\n".join(lines)


def _tag_exists(cwd: Path, tag: str) -> bool:
    proc = _run_git(["rev-parse", "-q", "--verify", f"refs/tags/{tag}"], cwd=cwd, check=False)
    return proc.returncode == 0


def _notes_destination(root: Path, version: str) -> Path:
    parts = version.split(".")
    if len(parts) >= 2:
        major_minor = ".".join(parts[:2])
    else:
        major_minor = version
    return root / f"docs/RELEASE_NOTES_v{major_minor}.md"


def create_release(version: str, notes_file: Path | None = None, dry_run: bool = False) -> str:
    root = _repo_root()
    if not re.match(r"^\d+\.\d+\.\d+$", version):
        raise ValueError(f"version must match semantic version format, got {version!r}")

    date = _release_date(root)
    target_tag = f"v{version}"
    last_tag = _previous_tag(root, target_tag)
    changes = _changes_since(root, last_tag)
    summary = SUMMARY_TEMPLATES.get(version, [f"Release {version} generated by scripts/release.py."])

    if notes_file is None:
        notes_file = _notes_destination(root, version)
    version_file = root / "VERSION"

    notes_file.parent.mkdir(parents=True, exist_ok=True)
    content = _build_notes(version, date, summary, changes)

    if dry_run:
        return content

    notes_file.write_text(content + "\n", encoding="utf-8")
    version_file.write_text(f"{version}\n", encoding="utf-8")

    tag = f"v{version}"
    if not _tag_exists(root, tag):
        _run_git(["tag", "-a", tag, "-m", f"Release {tag}"], cwd=root)

    return content


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Create a pilot release and tag it locally.")
    parser.add_argument("--version", default=DEFAULT_VERSION, help="Semantic version to release (default: 0.1.0)")
    parser.add_argument("--notes-file", type=Path, help="Optional override for the release notes path")
    parser.add_argument("--dry-run", action="store_true", help="Render notes without writing files or tagging")
    args = parser.parse_args(argv)

    try:
        content = create_release(args.version, notes_file=args.notes_file, dry_run=args.dry_run)
        if args.dry_run:
            sys.stdout.write(content)
        else:
            if args.notes_file:
                rel_path = args.notes_file
            else:
                rel_path = _notes_destination(_repo_root(), args.version)
            print(f"Release {args.version} prepared: {rel_path}")
        return 0
    except Exception as exc:  # pragma: no cover - surfaced by tests
        print(f"release failed: {exc}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
